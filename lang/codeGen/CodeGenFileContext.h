#ifndef CODEGEN_CODEGENFILECONTEXT_H
#define CODEGEN_CODEGENFILECONTEXT_H

#include <stack>
#include <algorithm>
#include <typeinfo>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/ExecutionEngine/GenericValue.h>
#include <llvm/Support/FormatVariadic.h>

#include "../ast/AST.h"
#include "../util/Util.h"

#include "types/CodeGenTypes.h"
#include "CodeGenVariable.h"
#include "CodeGenMangler.h"
#include "CodeGenBitcode.h"
#include "CodeGenChecker.h"
#include "CodeGenIdentifierResolver.h"
#include "helpers/CodeGenFunctionHelper.h"
#include "helpers/CodeGenTypeHelper.h"
#include "helpers/CodeGenVariableHelper.h"

using namespace llvm;

namespace stark
{

  /**
   * Represents a code block.
   * Wraps a llvm::BasicBlock 
   * and other information useful for the block creation.
   */
  class CodeGenBlock
  {
  public:
    BasicBlock *block;
    /* Holds local variables declared into the block */
    std::map<std::string, std::shared_ptr<CodeGenVariable>> locals;
    /**
     * Indicates if the block is a merge block.
     * A merge block is the last block delcared in a control flow instruction.
     */
    bool isMergeBlock;
    Value *returnValue;
  };

  /**
   * Code generation context.
   * Is in charge of generating  code from AST for a single source file.
   */
  class CodeGenFileContext
  {

    /** Name of the file being processed */
    std::string filename;

    /** Name of the stark module of the current context */
    std::string moduleName = "main";

    /** LLVM Module generated by the context */
    Module *llvmModule = nullptr;

    /** LLVM context */
    LLVMContext llvmContext;

    /** Block stack */
    std::stack<CodeGenBlock *> blocks;

    /** Program main function */
    Function *mainFunction = nullptr;

    /** Holds imported module names */
    std::vector<std::string> importedModuleNames;

    /** Holds language complex types (built-in and custom) */
    std::map<std::string, std::unique_ptr<CodeGenComplexType>> complexTypes;

    /** Holds array types (by type) */
    std::map<std::string, std::unique_ptr<CodeGenArrayComplexType>> arrayComplexTypes;

    /** Holds primary types */
    std::map<std::string, std::unique_ptr<CodeGenPrimaryType>> primaryTypes;

    /** Holds function types */
    std::map<std::string, std::unique_ptr<CodeGenFunctionType>> functionTypes;

    /** Holds closure types */
    std::map<std::string, std::unique_ptr<CodeGenClosureType>> closureTypes;

    /** Counter holding the next id to use to generate 
     * an anonymous item name (sucha as an anonymous function)
     */
    int anonymousIdCounter = 0;

    /** Run code generation in debug mode if enabled */
    bool debugEnabled = false;

    /** If set to true : generates a wrapping main function on the source file nd inject args (as string[] in the scope) */
    bool interpreterMode = false;

    /** Indicate if GC was initialized */
    bool gcInitialized = false;

    /** Mangler */
    std::unique_ptr<CodeGenMangler> mangler;

    /** Checker */
    std::unique_ptr<CodeGenChecker> checker;

    /** Identifier resolver */
    std::unique_ptr<CodeGenIdentifierResolver> identifierResolver;

    /** Function helper */
    std::unique_ptr<CodeGenFunctionHelper> functionHelper;

    /** Type helper */
    std::unique_ptr<CodeGenTypeHelper> typeHelper;

    /** Variable helper */
    std::unique_ptr<CodeGenVariableHelper> variableHelper;

    FileLocation currentLocation;

  private:
    /** Declare built-in complex types into the LLVMContext */
    void declareComplexTypes();

    /** Register primary types */
    void registerPrimaryTypes();

  public:
    stark::Logger logger;

    CodeGenFileContext(std::string filename) : filename(filename)
    {
      mangler = std::make_unique<CodeGenMangler>();
      checker = std::make_unique<CodeGenChecker>(this);
      identifierResolver = std::make_unique<CodeGenIdentifierResolver>(this);
      functionHelper = std::make_unique<CodeGenFunctionHelper>(this);
      typeHelper = std::make_unique<CodeGenTypeHelper>(this);
      variableHelper = std::make_unique<CodeGenVariableHelper>(this);
    }

    CodeGenMangler *getMangler() { return mangler.get(); }
    CodeGenChecker *getChecker() { return checker.get(); }
    CodeGenFunctionHelper *getFunctionHelper() { return functionHelper.get(); }
    CodeGenTypeHelper *getTypeHelper() { return typeHelper.get(); }
    CodeGenVariableHelper *getVariableHelper() { return variableHelper.get(); }
    CodeGenIdentifierResolver *getIdentifierResolver() { return identifierResolver.get(); }

    /** Generate llvm program code */
    CodeGenBitcode *generateCode(ASTBlock *root);

    /** Generate a complex type declaration */
    void declareComplexType(CodeGenComplexType *complexType);

    /** Declare a closure type from a function signature */
    CodeGenClosureType* declareClosureType(ASTFunctionSignature *signature);

    /** Declare a function type from a function signature */
    CodeGenFunctionType *declareFunctionType(ASTFunctionSignature *signature);

    /** Return matching complex type information from a type name */
    CodeGenComplexType *getComplexType(std::string typeName);

    /** Return matching complex type information from a type name */
    CodeGenClosureType *getClosureType(std::string typeName);

    /** 
     * Return matching array type (complex type) for a given enclosing type name.
     * If type not found, then it is created.
     */
    CodeGenArrayComplexType *getArrayComplexType(std::string typeName);

    /** Return matching primary type from a type name */
    CodeGenPrimaryType *getPrimaryType(std::string typeName);

    /** Return matching function type from a type name */
    CodeGenFunctionType *getFunctionType(std::string typeName);

    /** Check if the given type name is a primary type */
    bool isPrimaryType(std::string typeName) { return (primaryTypes.find(typeName) != primaryTypes.end()); }

    /** Check if the given type name is a function signature */
    bool isFunctionSignature(std::string typeName) { return (typeName.rfind("func_") == 0); }

    /** Check if the given type name is a closure signature */
    bool isClosureSignature(std::string typeName) { return (typeName.rfind("cls_") == 0); }

    /** Check if the given type name is an array type */
    bool isArrayType(std::string typeName) { return (typeName.rfind("array.") == 0); }

    /** Return LLVM type from a type name */
    Type *getType(std::string typeName);

    /** Try to find type name from LLVM type */
    std::string getTypeName(Type *type);

    void declareLocal(CodeGenVariable *var);
    CodeGenVariable *getLocal(std::string name);
    std::vector<CodeGenVariable *> getLocals();

    void addImportedModuleName(std::string moduleName) { importedModuleNames.push_back(moduleName); }
    std::vector<std::string> getImportedModuleNames() { return importedModuleNames; }
    bool isModuleImported(std::string moduleName) { return (std::find(importedModuleNames.begin(), importedModuleNames.end(), moduleName) == importedModuleNames.end()); }

    BasicBlock *getCurrentBlock() { return blocks.size() > 0 ? blocks.top()->block : nullptr; }
    void pushBlock(BasicBlock *block);
    void pushBlock(BasicBlock *block, bool inheritLocals);
    void popBlock();
    bool isMergeBlock() { return blocks.top()->isMergeBlock; }
    void setMergeBlock(bool isMerge) { blocks.top()->isMergeBlock = isMerge; }

    Value *getReturnValue() { return blocks.top()->returnValue; }
    void setReturnValue(Value *value) { blocks.top()->returnValue = value; }

    void setDebugEnabled(bool d) { debugEnabled = d; }
    void setInterpreterMode(bool m) { interpreterMode = m; }
    bool isInterpreterMode() { return interpreterMode; }

    /** Return a unique identifier 
     * for the source file being processed 
     */
    int getNextAnonymousId()
    {
      anonymousIdCounter++;
      return anonymousIdCounter;
    }

    /**
    * Try to initialize the memory manager. 
    * Can be called many times, will initialize only once, if conditions are met.
    */
    void initMemoryManager();

    /** Create a memory allocation using the memory manager. */
    Value *createMemoryAllocation(Type *type, Value *size, BasicBlock *insertAtEnd);

    bool isRuntimeFunctionName(std::string functionName);

    std::string getModuleName() { return moduleName; }
    void setModuleName(std::string name) { moduleName = name; }

    std::string getFilename() { return filename; }

    /** Returns llvm module of the context.
     * Be careful : it is only available during code generation
     * */
    Module *getLlvmModule() { return llvmModule; }
    LLVMContext &getLlvmContext() { return llvmContext; }

    void setCurrentLocation(FileLocation l) { currentLocation = l; }
    FileLocation getCurrentLocation() { return currentLocation; }
  };

} // namespace stark

#endif