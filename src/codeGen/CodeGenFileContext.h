#ifndef CODEGEN_CODEGENFILECONTEXT_H
#define CODEGEN_CODEGENFILECONTEXT_H

#include <stack>
#include <typeinfo>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/ExecutionEngine/GenericValue.h>
#include <llvm/Support/FormatVariadic.h>

#include "../ast/AST.h"
#include "../util/Util.h"

#include "types/CodeGenComplexType.h"
#include "types/CodeGenPrimaryType.h"
#include "CodeGenVariable.h"
#include "CodeGenMangler.h"
#include "CodeGenBitcode.h"
#include "CodeGenChecker.h"

using namespace llvm;

namespace stark
{

  /**
   * Represents a code block.
   * Wraps a llvm::BasicBlock 
   * and other information useful for the block creation.
   */
  class CodeGenBlock
  {
  public:
    BasicBlock *block;
    /* Holds local variables declared into the block */
    std::map<std::string, std::shared_ptr<CodeGenVariable>> locals;
    /**
     * Indicates if the block is a merge block.
     * A merge block is the last block delcared in a control flow instruction.
     */
    bool isMergeBlock;
    Value *returnValue;
  };

  /**
   * Code generation context.
   * Is in charge of generating  code from AST for a single source file.
   */
  class CodeGenFileContext
  {

    /** Name of the file being processed */
    std::string filename;

    /** Name of the stark module of the current context */
    std::string moduleName = "main";

    /** LLVM Module generated by the context */
    Module *llvmModule = nullptr;

    /** LLVM context */
    LLVMContext llvmContext;

    /** Block stack */
    std::stack<CodeGenBlock *> blocks;

    /** Program main function */
    Function *mainFunction = nullptr;

    /** Holds language complex types (built-in and custom) */
    std::map<std::string, std::unique_ptr<CodeGenComplexType>> complexTypes;

    /** Holds array types (by type) */
    std::map<std::string, std::unique_ptr<CodeGenArrayComplexType>> arrayComplexTypes;

    /** Holds primary types */
    std::map<std::string, std::unique_ptr<CodeGenPrimaryType>> primaryTypes;

    /** Run code generation in debug mode if enabled */
    bool debugEnabled = false;

    /** If set to true : generates a wrapping main function on the source file nd inject args (as string[] in the scope) */
    bool interpreterMode = false;

    /** Indicate if GC was initialized */
    bool gcInitialized = false;

    /** Mangler */
    std::unique_ptr<CodeGenMangler> mangler;

    /** Checker */
    std::unique_ptr<CodeGenChecker> checker;

  private:
    /** Declare built-in complex types into the LLVMContext */
    void declareComplexTypes();

    /** Register primary types */
    void registerPrimaryTypes();

  public:
    stark::Logger logger;

    CodeGenFileContext(std::string filename) : filename(filename)
    {
      mangler = std::make_unique<CodeGenMangler>();
      checker = std::make_unique<CodeGenChecker>(this);
    }

    CodeGenMangler *getMangler() { return mangler.get(); }
    CodeGenChecker *getChecker() { return checker.get(); }

    /** Generate llvm program code */
    CodeGenBitcode *generateCode(ASTBlock *root);

    /** Generate a complex type declaration */
    void declareComplexType(CodeGenComplexType *complexType);

    /** Return matching complex type information from a type name */
    CodeGenComplexType *getComplexType(std::string typeName);

    /** Return matching array type (complex type) for a given enclosing type name */
    CodeGenArrayComplexType *getArrayComplexType(std::string typeName);

    /** Return matching primary type from a type name */
    CodeGenPrimaryType *getPrimaryType(std::string typeName);

    /** Check if the given type name is a primary type */
    bool isPrimaryType(std::string typeName) { return (primaryTypes.find(typeName) != primaryTypes.end()); }

    /** Return LLVM type from a type name */
    Type *getType(std::string typeName);

    /** Try to find type name from LLVM type */
    std::string getTypeName(Type *type);

    void declareLocal(CodeGenVariable *var);
    CodeGenVariable *getLocal(std::string name);

    BasicBlock *getCurrentBlock() { return blocks.size() > 0 ? blocks.top()->block : nullptr; }
    void pushBlock(BasicBlock *block);
    void pushBlock(BasicBlock *block, bool inheritLocals);
    void popBlock();
    bool isMergeBlock() { return blocks.top()->isMergeBlock; }
    void setMergeBlock(bool isMerge) { blocks.top()->isMergeBlock = isMerge; }

    Value *getReturnValue() { return blocks.top()->returnValue; }
    void setReturnValue(Value *value) { blocks.top()->returnValue = value; }

    void setDebugEnabled(bool d) { debugEnabled = d; }
    void setInterpreterMode(bool m) { interpreterMode = m; }
    bool isInterpreterMode() { return interpreterMode; }

    /**
    * Try to initialize the memory manager. 
    * Can be called many times, will initialize only once, if conditions are met.
    */
    void initMemoryManager();

    /** Create a memory allocation using the memory manager. */
    Value *createMemoryAllocation(Type *type, Value *size, BasicBlock *insertAtEnd);

    bool isRuntimeFunctionName(std::string functionName);

    std::string getModuleName() { return moduleName; }
    void setModuleName(std::string name) { moduleName = name; }

    /** Returns llvm module of the context.
     * Be careful : it is only available during code generation
     * */
    Module *getLlvmModule() { return llvmModule; }

    LLVMContext &getLlvmContext() { return llvmContext; }
  };

} // namespace stark

#endif