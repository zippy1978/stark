use num_bigint::BigInt;
use crate::ast;
use crate::parser::LexicalError;
use crate::parser::Token;

grammar(filename: &String);

pub Stmts: ast::Stmts = <Statment*> => <>;

Statment: ast::Stmt = {
    ExpressionStatment,
    VariableDefinition,
    FunctionDefinition,
    Assign,
};

ExpressionStatment: ast::Stmt = {
    <location:@L> <e:Expression> => {
        ast::Stmt {
            location,
            node: ast::StmtKind::Expr { value: Box::new(e) }
        }
    },   
};

// Variable

VariableDefinition: ast::Stmt = {
    <location:@L> <name:Identifier> ":" <var_type:Identifier> => {
        ast::Stmt {
            location,
            node: ast::StmtKind::VarDef { name: name, var_type: var_type }
        }
    },
};

// Function

// TODO
//Args: ast::Args = ("\n")* <Arg*> => <>;

FunctionType: String = {
     "=>" <returns:Identifier> => returns
};

FunctionDefinition: ast::Stmt = {
    <location:@L> "func" <name:Identifier> "(" ")" <returns:FunctionType?> "{" <stmts:Stmts>"}" => {
        ast::Stmt {
            location,
            node: ast::StmtKind::FuncDef { name: name, args: Box::new(ast::Args{location, node: Vec::new()}), body: stmts, returns }
        }
    },
};

// Assign

Assign: ast::Stmt = {
    <location:@L> <target:Expression> "=" <value:Expression> => {
        ast::Stmt {
            location,
            node: ast::StmtKind::Assign { target: Box::new(target), value: Box::new(value) }
        }
    },
};

Expression: ast::Expr = {
    <location:@L> <i:Identifier> => ast::Expr {
        location,
        node: ast::ExprKind::Name { id: i}
    },
    <location:@L> <i:Integer> => ast::Expr {
        location,
        node: ast::ExprKind::Constant { value: ast::Constant::Int(i)}
    },
};

// Literals

Identifier: String = <s:name> => {
    match s {
        Token::Identifier(name) => name,
        _ => panic!(),
    }
};

Integer: BigInt = <i:integer> => {
    match i {
        Token::Integer(int) => int,
        _ => panic!(),
    }
};

// Hook external lexer:
extern {
    type Location = ast::Location;
    type Error = LexicalError;

    enum Token {
        name => Token::Identifier(_),
        integer => Token::Integer(_),
        ":" => Token::Colon,
        "=" => Token::Equal,
        "func" => Token::Func,
        "=>" => Token::Arrow,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "," => Token::Comma,
      }
}