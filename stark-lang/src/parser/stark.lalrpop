use num_bigint::BigInt;
use crate::ast;
use crate::parser::LexicalError;
use crate::parser::Token;

grammar(filename: &String);

pub Stmts: ast::Stmts = <Statment*> => <>;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
      let mut v = v;
      v.push(e);
      v
    },
};

Statment: ast::Stmt = {
    ExpressionStatment,
    VariableDeclaration,
    FunctionDefinition,
    Assign,
    Import,
};

ExpressionStatment: ast::Stmt = {
    <location:@L> <e:Expression> => {
        ast::Stmt {
            location,
            node: ast::StmtKind::Expr { value: Box::new(e) },
            info: ast::NodeInfo::new(),
        }
    },   
};

// Import
Import: ast::Stmt = {
    <location:@L> "import" <name:Identifier> => {
        ast::Stmt {
            location,
            node: ast::StmtKind::Import { name: name },
            info: ast::NodeInfo::new(),
        }
    },
}

// Variable

VariableDeclaration: ast::Stmt = {
    <location:@L> <name:Identifier> ":" <var_type:Identifier> => {
        ast::Stmt {
            location,
            node: ast::StmtKind::VarDecl { name: name, var_type: var_type },
            info: ast::NodeInfo::new(),
        }
    },
};

// Function

Arg: ast::Arg = {
    <name:Identifier> ":" <var_type:Identifier> => {
        ast::Arg { name: name, var_type: var_type }
    },
};

FunctionType: ast::Ident = {
    "=>" <returns:Identifier> => returns
};

FunctionDefinition: ast::Stmt = {
    <location:@L> "func" <name:Identifier> "(" <args:Comma<Arg>?> ")" <returns:FunctionType?> "{" <stmts:Stmts>"}" => {
        ast::Stmt {
            location,
            node: ast::StmtKind::FuncDef { 
                name: name, 
                args: match args {
                    Some(a) => Box::new(a),
                    None => Box::new(ast::Args::new()),
                }, 
                body: stmts, 
                returns 
            },
            info: ast::NodeInfo::new(),
        }
    },
};

// Assign

Assign: ast::Stmt = {
    <location:@L> <target:Identifier> "=" <value:Expression> => {
        ast::Stmt {
            location,
            node: ast::StmtKind::Assign { target: target, value: Box::new(value) },
            info: ast::NodeInfo::new(),
        }
    },
};

// Expressions

Expression: ast::Expr = {
    Constants,
    Call,
};

// Call

Call: ast::Expr = {
    <location:@L> <i:Identifier> "("  <params:Comma<Expression>?> ")" => ast::Expr {
        location,
        node: ast::ExprKind::Call {
            id: i, 
            params: match params {
                Some(p) => Box::new(p),
                None => Box::new(ast::Params::new())
            }
        },
        info: ast::NodeInfo::new(),
    },
};

// Literals 

Constants: ast::Expr = {
    <location:@L> <i:Identifier> => ast::Expr {
        location,
        node: ast::ExprKind::Name { id: i},
        info: ast::NodeInfo::new(),
    },
    <location:@L> <i:Integer> => ast::Expr {
        location,
        node: ast::ExprKind::Constant { value: ast::Constant::Int(i)},
        info: ast::NodeInfo::new(),
    },
    <location:@L> <f:Float> => ast::Expr {
        location,
        node: ast::ExprKind::Constant { value: ast::Constant::Float(f)},
        info: ast::NodeInfo::new(),
    },
    <location:@L> <b:Boolean> => ast::Expr {
        location,
        node: ast::ExprKind::Constant { value: ast::Constant::Bool(b)},
        info: ast::NodeInfo::new(),
    },
};

Identifier: ast::Ident =  <location:@L> <s:name> => {
    match s {
        Token::Identifier(name) => ast::Ident {location, node: name, info: ast::NodeInfo::new(),},
        _ => panic!(),
    }
};

Integer: BigInt = {
    <i:integer> => {
        match i {
            Token::Integer(int) => int,
            _ => panic!(),
        }
    },
    "-" <i:integer> => {
        match i {
            Token::Integer(int) => int * -1,
            _ => panic!(),
        }
    },
};

Float: f64 = {
    <f:float> => {
        match f {
            Token::Float(float) => float,
            _ => panic!(),
        }
    },
    "-" <f:float> => {
        match f {
            Token::Float(float) => float * -1.0,
            _ => panic!(),
        }
    },
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

// Hook external lexer:
extern {
    type Location = ast::Location;
    type Error = LexicalError;

    enum Token {
        name => Token::Identifier(_),
        integer => Token::Integer(_),
        float => Token::Float(_),
        ":" => Token::Colon,
        "=" => Token::Equal,
        "func" => Token::Func,
        "=>" => Token::Arrow,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "," => Token::Comma,
        "true" => Token::True,
        "false" => Token::False,
        "-" => Token::Minus,
        "import" => Token::Import,
      }
}