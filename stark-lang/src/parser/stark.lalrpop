use num_bigint::BigInt;
use crate::ast;
use crate::parser::LexicalError;
use crate::parser::Token;

grammar(filename: &String);

pub Stmts: ast::Stmts = ("\n")* <Statment*> => <>;

Statment: ast::Stmt = {
    ExpressionStatement,
    VariableDefinition,
    Assign,
};

ExpressionStatement: ast::Stmt = {
    <location:@L> <e:Expression> ("\n")* => {
        ast::Stmt {
            location,
            node: ast::StmtKind::Expr { value: Box::new(e) }
        }
    },   
};

VariableDefinition: ast::Stmt = {
    <location:@L> <name:Identifier> ":" <var_type:Identifier> ("\n")* => {
        ast::Stmt {
            location,
            node: ast::StmtKind::VarDef { name: name, var_type: var_type }
        }
    },
};

Assign: ast::Stmt = {
    <location:@L> <target:Expression> "=" <value:Expression> ("\n")* => {
        ast::Stmt {
            location,
            node: ast::StmtKind::Assign { target: Box::new(target), value: Box::new(value) }
        }
    },
};

Expression: ast::Expr = {
    <location:@L> <i:Identifier> => ast::Expr {
        location,
        node: ast::ExprKind::Name { id: i}
    },
    <location:@L> <i:Integer> => ast::Expr {
        location,
        node: ast::ExprKind::Constant { value: ast::Constant::Int(i)}
    },
};

Identifier: String = <s:name> => {
    match s {
        Token::Identifier(name) => name,
        _ => panic!(),
    }
};

Integer: BigInt = <i:integer> => {
    match i {
        Token::Integer(int) => int,
        _ => panic!(),
    }
};

// Hook external lexer:
extern {
    type Location = ast::Location;
    type Error = LexicalError;

    enum Token {
        name => Token::Identifier(_),
        integer => Token::Integer(_),
        "\n" => Token::NewLine,
        ":" => Token::Colon,
        "=" => Token::Equal,
        "func" => Token::Func,
        "=>" => Token::Arrow,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
      }
}